I"ø+<p>Last week I was working on a code challenge about an IP address converter. My
method had 19 lines, but it worked. Out of curiosity, I looked into other
solutions to see how I could simplify or improve my response.</p>

<p>That was when I found a responseâ€¦ With just 1 line of code ğŸ˜±ğŸ˜±ğŸ¤¯</p>

<p><img class="pull-left" src="https://media.giphy.com/media/Um3ljJl8jrnHy/giphy.gif" alt="mindblown animation" style="width: 200px;" /></p>

<p>I love inject. To be more specific, I love Enumerable#inject. I find it easy to read and easy to use. Itâ€™s powerful and it lets me be more concise. Enumerable#inject is a good thing.</p>

<p>Of course, I didnâ€™t always love it. When I was new to Ruby I didnâ€™t understand what it was, so I found it hard to follow. However, finding it hard to understand didnâ€™t make me run from it, instead I wanted to know what all the hype was about. Enumerable#inject is an often used method by many great Rubyists, and I wanted to know what I was missing.</p>

<p>So, to learn about Enumerable#inject I did what I always do, I used it every possible way I could think of.</p>

<p>Example 1: Summing numbers
Summing numbers is the most common example for using inject. You have an array of numbers and you want the sum of those numbers.</p>

<table>
  <tbody>
    <tr>
      <td>[1, 2, 3, 4].inject(0) {</td>
      <td>result, element</td>
      <td>result + element } # =&gt; 10</td>
    </tr>
  </tbody>
</table>

<p>If the example isnâ€™t straightforward, donâ€™t worry, weâ€™re going to break it down. The inject method takes an argument and a block. The block will be executed once for each element contained in the object that inject was called on ([1,2,3,4] in our example). The argument passed to inject will be yielded as the first argument to the block, the first time itâ€™s executed. The second argument yielded to the block will be the first element of the object that we called inject on.</p>

<p>So, the block will be executed 4 times, once for every element of our array ([1,2,3,4]). The first time the block executes the result argument will have a value of 0 (the value we passed as an argument to inject) and the element argument will have a value of 1 (the first element in our array).</p>

<p>You can do anything you want within the block, but the return value of the block is very important. The return value of the block will be yielded as the result argument the next time the block is executed.</p>

<p>In our example we add the result, 0, to the element, 1. Therefore, the return value of the block will be 0 + 1, or 1. This will result in 1 being yielded as the result argument the second time the block is executed.</p>

<p>The second time the block is executed the result of the previous block execution, 1, will be yielded as the result, and the second element of the array will be yielded as the element. Again the result, 1, and the element, 2 will be added together, resulting in the return value of the block being 3.</p>

<p>The third time the block is executed the result of the second block execution, 3, is yielded as the result argument and the third element of the array, 3, will be yielded as the element argument. Again, the result and the element will be added, and the return value of the block for the third execution will be 6.</p>

<p>The fourth time will be the final time the block is executed since there are only 4 elements in our array. The result value will be 6, the result from the third execution of the block, and the element will be 4, the fourth element of the array. The block will execute, adding four plus six, and the return value of the block will be 10. On the final execution of the block the return value is used as the return value of the inject method; therefore, as the example shows, the result of executing the code above is 10.</p>

<p>Thatâ€™s the very long version of how inject works, but you could actually shortcut one of the block executions by not passing an argument to inject.</p>

<table>
  <tbody>
    <tr>
      <td>[1, 2, 3, 4].inject {</td>
      <td>result, element</td>
      <td>result + element } # =&gt; 10</td>
    </tr>
  </tbody>
</table>

<p>As the example shows, the argument to inject is actually optional. If a default value is not passed in as an argument the first time the block executes the first argument (result from our example) will be set to the first element of the enumerable (1 from our example) and the second argument (element from our example) will be set to the second element of the enumerable (2 from our example).</p>

<p>In this case the block will only need to be executed 3 times, since the first execution will yield both the first and the second element. The first time the block executes it will add the result, 1, to the element, 2, and return a value of 3. The second time the block executes the result will be 3 and the element will also be 3. All additional steps will be the same, and the result will be 10 once again.</p>

<p>Summing numbers with inject is a simple example of taking an array of numbers and building a resulting sum one element at a time.</p>

<p>Example 2: Building a Hash
Sometimes youâ€™ll have data in one format, but you really want it in another. For example, you may have an array that contains keys and values as pairs, but itâ€™s really just an array of arrays. In that case, inject is a nice solution for quickly converting your array of arrays into a hash.</p>

<p>hash = [[:first_name, â€˜Shaneâ€™], [:last_name, â€˜Harvieâ€™]].inject({}) do |result, element|
  result[element.first] = element.last
  result
end</p>

<p>hash # =&gt; {:first_name=&gt;â€Shaneâ€, :last_name=&gt;â€Harvieâ€}</p>

<p>As the example shows, I start with an empty hash (the argument to inject) and I iterate through each element in the array adding the key and value one at a time to the result. Also, since the result of the block is the next yielded result, I need to add to the hash, but explicitly return the result on the following line.</p>

<p>Ola Bini and rubikitch both pointed out that you can also create a hash from an array with the following code.</p>

<p>Hash[*[[:first_name, â€˜Shaneâ€™], [:last_name, â€˜Harvieâ€™]].flatten] # =&gt; {:first_name=&gt;â€Shaneâ€, :last_name=&gt;â€Harvieâ€}</p>

<p>Of course, I can do other things in inject also, such as converting the keys to be strings and changing the names to be lowercase.</p>

<p>hash = [[:first_name, â€˜Shaneâ€™], [:last_name, â€˜Harvieâ€™]].inject({}) do |result, element|
  result[element.first.to_s] = element.last.downcase
  result
end</p>

<p>hash # =&gt; {â€œfirst_nameâ€=&gt;â€shaneâ€, â€œlast_nameâ€=&gt;â€harvieâ€}</p>

<p>This is a central value for inject, it allows me to easily convert an enumerable into an object that is useful for the problem Iâ€™m trying to solve.</p>

<p>Example 3: Building an Array
Enumerable gives you many methods you need for manipulating arrays. For example, if want all the integers of an array, that are even, as strings, you can do so chaining various methods from Enumerable.</p>

<table>
  <tbody>
    <tr>
      <td>[1, 2, 3, 4, 5, 6].select {</td>
      <td>element</td>
      <td>element % 2 == 0 }.collect {</td>
      <td>element</td>
      <td>element.to_s } # =&gt; [â€œ2â€, â€œ4â€, â€œ6â€]</td>
    </tr>
  </tbody>
</table>

<p>Chaining methods of Enumerable is a solution thatâ€™s very comfortable for many developers, but as the chain gets longer I prefer to use inject. The inject method allows me to handle everything I need without having to chain multiple independent methods.</p>

<p>The code below achieves the same thing in one method, and is just as readable, to me.
array = [1, 2, 3, 4, 5, 6].inject([]) do |result, element|
  result Â«Â element.to_s if element % 2 == 0
  result
end</p>

<p>array # =&gt; [â€œ2â€, â€œ4â€, â€œ6â€]</p>

<p>Of course, that example is a bit contrived; however, a realistic example is when you have an object with two different properties and you want to build an array of one, conditionally based on the other. A more concrete example is an array of test result objects that know if theyâ€™ve failed or succeeded and they have a failure message if theyâ€™ve failed. For reporting, you want all the failure messages.</p>

<p>You can get this with the built in methods of Enumerable.</p>

<p>TestResult = Struct.new(:status, :message)
results = [
  TestResult.new(:failed, â€œ1 expected but was 2â€),
  TestResult.new(:sucess),
  TestResult.new(:failed, â€œ10 expected but was 20â€)
]</p>

<p>messages = results.select { |test_result| test_result.status == :failed }.collect { |test_result| test_result.message }
messages # =&gt; [â€œ1 expected but was 2â€, â€œ10 expected but was 20â€]</p>

<p>But, itâ€™s not obvious what you are doing until you read the entire line. You could build the array the same way using inject and if you are comfortable with inject it reads slightly cleaner.</p>

<p>TestResult = Struct.new(:status, :message)
results = [
  TestResult.new(:failed, â€œ1 expected but was 2â€),
  TestResult.new(:sucess),
  TestResult.new(:failed, â€œ10 expected but was 20â€)
]</p>

<p>messages = results.inject([]) do |messages, test_result|
  messages Â«Â test_result.message if test_result.status == :failed
  messages
end
messages # =&gt; [â€œ1 expected but was 2â€, â€œ10 expected but was 20â€]</p>

<p>I prefer to build what I want using inject instead of chaining methods of Enumerable and effectively building multiple objects on the way to what I need.</p>

<p>Example 4: Building a Hash (again)
Building from the Test Result example you might want to group all results by their status. The inject method lets you easily do this by starting with an empty hash and defaulting each key value to an empty array, which is then appended to with each element that has the same status.</p>

<p>TestResult = Struct.new(:status, :message)
results = [
  TestResult.new(:failed, â€œ1 expected but was 2â€),
  TestResult.new(:sucess),
  TestResult.new(:failed, â€œ10 expected but was 20â€)
]</p>

<p>grouped_results = results.inject({}) do |grouped, test_result|
  grouped[test_result.status] = [] if grouped[test_result.status].nil?
  grouped[test_result.status] Â«Â test_result
  grouped
end</p>

<p>grouped_results</p>
<h1 id="-failed--">Â» {:failed =&gt; [</h1>
<h1 id="----struct-testresult-statusfailed-message1-expected-but-was-2">Â»    #&lt;struct TestResult status=:failed, message=â€1 expected but was 2â€&gt;,</h1>
<h1 id="----struct-testresult-statusfailed-message10-expected-but-was-20">Â»    #&lt;struct TestResult status=:failed, message=â€10 expected but was 20â€&gt;],</h1>
<h1 id="--sucess---struct-testresult-statussucess-messagenil-">Â»  :sucess =&gt; [ #&lt;struct TestResult status=:sucess, message=nil&gt; ]</h1>
<h1 id="-">Â» }</h1>

<p>You might be sensing a theme here.</p>

<p>Conclusion
How do I know when I want to use inject? I like to use inject anytime I am building an object a piece at a time. In the case of summing, creating a hash, or an array Iâ€™m building a result by applying changes based on the elements of the enumerable. After Iâ€™m done applying changes for each element, I have the finished object Iâ€™m looking for.</p>

:ET