I"ã<p>Last week I did a code challenge about an IP address converter. My
method had 19 lines, but it worked. Out of curiosity, I looked into other
solutions to see how I could simplify or improve my response. That was when I
found a resopnseâ€¦ With just 1 line of code ðŸ˜±ðŸ˜±ðŸ¤¯</p>

<p><img class="pull-left" src="https://media.giphy.com/media/Um3ljJl8jrnHy/giphy.gif" alt="mindblown animation" style="width: 200px;" /></p>

<p>This solution that I found used the <code class="highlighter-rouge">inject</code> method. I tried to understand
it but it was a bit confusing.</p>

<p>So I googled for inject examples. I
found <a href="http://blog.jayfields.com/2008/03/ruby-inject.html">this</a> incredible
article about <code class="highlighter-rouge">Enumerable#inject</code> and now I want to write down what I
learned from itâ€¦ You know, for future reference.</p>

<p><br /></p>

<p>Example 1: You have an array of numbers and you want the sum of those numbers</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1, 2, 3, 4].inject(0) { |result, element| result + element } # =&gt; 10
</code></pre></div></div>

<p><br /></p>

<p>The inject method takes an argument and a block.
The block will be executed once for each element contained in the object that
inject was called on ([1,2,3,4] in our example). The argument passed to inject
will be yielded as the first argument to the block, the first time itâ€™s
executed. The second argument yielded to the block will be the first element of
the object that we called inject on.</p>

<p>So, the block will be executed 4 times, once for every element of our array
([1,2,3,4]). The first time the block executes the result argument will have a
value of 0 (the value we passed as an argument to inject) and the element
argument will have a value of 1 (the first element in our array).</p>

<p>The return value of the block will be yielded as the result argument the next
time the block is executed.</p>

<p>In our example we add the result, 0, to the element, 1. Therefore, the return
value of the block will be 0 + 1, or 1. This will result in 1 being yielded as
the result argument the second time the block is executed.</p>

<p>The second time the block is executed the result of the previous block
execution, 1, will be yielded as the result, and the second element of the
array will be yielded as the element. Again the result, 1, and the element,
2 will be added together, resulting in the return value of the block being 3.</p>

<p>The above line of thought will be repeated for third and fourth elements of our
example array, and the return value of this inject method will is 10.</p>

<p><br /></p>

<p>Also, the argument to inject is actually optional:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1, 2, 3, 4].inject { |result, element| result + element } # =&gt; 10
</code></pre></div></div>

<p><br /></p>

<p>If a default value is not passed in as an argument the first time the block
executes the first argument (result from our example) will be set to the first
element of the enumerable (1 from our example) and the second argument (element
from our example) will be set to the second element of the enumerable
(2 from our example).</p>

<p>In this case the block will only need to be executed 3 times, since the first
execution will yield both the first and the second element.</p>

<p><br /></p>

<p>Example 2: You have an array of arrays and you want to convert it into a hash.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[:first_name, 'Harvey'], [:last_name, 'Specter']].inject({}) do |result, element|
  result[element.first] = element.last.upcase
  result
end

# =&gt; {:first_name=&gt;"Harvey", :last_name=&gt;"Specter"}
</code></pre></div></div>

<p>As the example shows, I start with an empty hash (the argument to inject) and I
iterate through each element in the array adding the key and value one at a time
to the result. Also, since the result of the block is the next yielded result,
I need to add to the hash, but explicitly return the result on the following
line.</p>

<p>Inject, allows us to easily convert an enumerable into an object nad manipulate
it at the same time, making our code more concise.</p>

<p><br /></p>

<p>Example 3: Selecting integers of an array that are even, as strings</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1, 2, 3, 4, 5, 6].select { |element| element % 2 == 0 }.collect { |element| element.to_s } # =&gt; ["2", "4", "6"]
</code></pre></div></div>

<p>Inject method allows me to handle everything I need without having to chain
multiple independent methods. The code below achieves the same thing in one
method, and is just as readable, to me.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1, 2, 3, 4, 5, 6].inject([]) do |result, element|
  result &lt;&lt; element.to_s if element % 2 == 0
  result
end

# =&gt; ["2", "4", "6"]
</code></pre></div></div>
<p><br /></p>

<p>Example 4: Group results by their status</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TestResult = Struct.new(:status, :message)
results = [
  TestResult.new(:failed, "1 expected but was 2"),
  TestResult.new(:sucess),
  TestResult.new(:failed, "10 expected but was 20")
]

results.inject({}) do |grouped, test_result|
  grouped[test_result.status] = [] if grouped[test_result.status].nil?
  grouped[test_result.status] &lt;&lt; test_result
  grouped
end

# =&gt; {:failed =&gt; [
# =&gt;    #&lt;struct TestResult status=:failed, message="1 expected but was 2"&gt;,
# =&gt;    #&lt;struct TestResult status=:failed, message="10 expected but was 20"&gt;],
# =&gt;  :sucess =&gt; [ #&lt;struct TestResult status=:sucess, message=nil&gt; ]
# =&gt; }
</code></pre></div></div>

<p>The inject method lets you easily do this by starting with an empty hash and
defaulting each key value to an empty array, which is then appended to with each
element that has the same status.</p>
:ET